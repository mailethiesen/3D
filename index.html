<html>
<head>
<title>
</title>
<style>

@import url('https://fonts.googleapis.com/css?family=Orbitron');

  body 
  {
    margin: 0
  }
  canvas 
  {
    width: 100%; height: 100%;
  }
  #container { 
    width: 100%;
    height: 150px;

}

#buttons {
    font-family: 'Orbitron', sans-serif;
    font-size: 40px;
    color:#f5f3a0;
    background-color: #000;
    position:absolute;
    z-index:5;
    text-align: center;
    bottom:0px;
    width : 100%;
    height : 20%;
    display: flex;
    justify-content: center; /* align horizontal */
    align-items: center; /* align vertical */

}

a:-webkit-any-link {
  text-decoration: none;
}



</style>
</head>
<body>
<script src="js/three.js"></script>
<script src="js/OrbitControls.js"></script>
<script src="js/OBJLoader.js"></script>
<script src="js/MTLLoader.js"></script>


<script type="text/javascript">

// add javascript monitor
(function(){var script=document.createElement('script');script.onload=function(){var stats=new Stats();document.body.appendChild(stats.dom);requestAnimationFrame(function loop(){stats.update();requestAnimationFrame(loop)});};script.src='//rawgit.com/mrdoob/stats.js/master/build/stats.min.js';document.head.appendChild(script);})()





// setting up the camera
  var scene = new THREE.Scene( );
  var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000);
  // 0.1 is the near clipping plane and 1000 is the far clipping pane.

 



  // setting up the renderer
  var renderer = new THREE.WebGLRenderer( );
  renderer.setSize( window.innerWidth, window.innerHeight );
  document.body.appendChild( renderer.domElement );





  // auto detect when the viewport changes size
  window.addEventListener( 'resize', function( )
    {
      var width = window.innerWidth;
      var height = window.innerHeight;
      renderer.setSize( width, height ); 
      // update the camera aspect
      camera.aspect = width / height;
      camera.updateProjectionMatrix( );
    } );

  controls = new THREE.OrbitControls( camera, renderer.domElement );







// // add sphere
//   var geometry1 = new THREE.SphereBufferGeometry( 5, 32, 32 ); // radius, segmentsWidth, segmentsHeight
//   var material1 = new THREE.MeshLambertMaterial( {color: 0xFFFFFF} );
//   var sphere = new THREE.Mesh( geometry1, material1 );
//   scene.add( sphere );

//   sphere.position.x = 0;
//   sphere.position.y = 0;
//   sphere.position.z = 0;




var sphereGeom =  new THREE.SphereGeometry( 5, 500, 500 ); // radius, segmentsWidth, segmentsHeight
  mirrorSphereCamera = new THREE.CubeCamera( 0.1, 5000, 512 );
  // mirrorCubeCamera.renderTarget.minFilter = THREE.LinearMipMapLinearFilter;
  scene.add( mirrorSphereCamera );
  var mirrorSphereMaterial = new THREE.MeshBasicMaterial( { envMap: mirrorSphereCamera.renderTarget } );
  mirrorSphere = new THREE.Mesh( sphereGeom, mirrorSphereMaterial );
  mirrorSphere.position.set(0,0,0);
  mirrorSphereCamera.position = mirrorSphere.position;
  scene.add(mirrorSphere);





// add cube

  var geometry = new THREE.BoxBufferGeometry( 60, 60, 60 );

  var cubeMaterials = 
  [
    new THREE.MeshLambertMaterial( { map: new THREE.TextureLoader( ).load( 'DP205278.jpg' ), side: THREE.DoubleSide } ), // Outter Right Side
    // new THREE.MeshLambertMaterial( { map: new THREE.TextureLoader( ).load( 'DT8789.jpg' ), side: THREE.DoubleSide } ), // Inner Right Side

    new THREE.MeshLambertMaterial( { map: new THREE.TextureLoader( ).load( 'DP205279.jpg' ), side: THREE.DoubleSide } ), //Outter Left Side

    new THREE.MeshLambertMaterial( { map: new THREE.TextureLoader( ).load( 'DT8788.jpg' ), side: THREE.DoubleSide } ), //inside top?

    new THREE.MeshLambertMaterial( { map: new THREE.TextureLoader( ).load( 'DT1157.jpg' ), side: THREE.DoubleSide } ), // inside bottom?

    new THREE.MeshLambertMaterial( { map: new THREE.TextureLoader( ).load( 'DP205280.jpg' ), side: THREE.DoubleSide } ), //Both Sides Top
    

    new THREE.MeshLambertMaterial( { map: new THREE.TextureLoader( ).load( 'DP205281.jpg' ), side: THREE.DoubleSide } ), //Both Sides Bottom


    // new THREE.MeshLambertMaterial( { map: new THREE.TextureLoader( ).load( 'DP205282.jpg' ), side: THREE.DoubleSide } ), //Outter Front Side


    // new THREE.MeshLambertMaterial( { map: new THREE.TextureLoader( ).load( 'DP205280.jpg'), side: THREE.DoubleSide } ), //Outter Back Side
  ];
  


  // create a material, color, or image texture
  var material = new THREE.MeshFaceMaterial( cubeMaterials );
  // var material = new THREE.MeshBasicMaterial( {color: 0xffffff, wireframe: true } );
  

  var cube = new THREE.Mesh( geometry, material );
  scene.add( cube );

  cube.position.x = 0;
  cube.position.y = 0;
  cube.position.z = 0;
  


  camera.position.z = 100;

  // add ambient light
  var ambientLight = new THREE.AmbientLight( 0xFFFFFF //light color
  , 1 //intensity value 
  );
  scene.add( ambientLight );

  // var light1 = new THREE.PointLight( 0xFF0040, 2, 50 );
  // scene.add( light1 );

  // var light2 = new THREE.PointLight( 0x0040FF, 2.5, 50 );
  // scene.add( light2 );

  // var light3 = new THREE.PointLight( 0x80FF80, 3, 50 );
  // scene.add( light3 );

  // game logic
  





  var update = function( )
  {
    cube.rotation.x += 0.000005;
    // cube.rotation.x -= SPEED * 2;
    cube.rotation.y += 0.0005;
    var time = Date.now( ) * 0.0005;

    // light1.postion.x = Math.sin( time * 0.7 ) * 30;
    // light1.postion.y = Math.con( time * 0.5 ) * 40;
    // light1.postion.z = Math.con( time * 0.3 ) * 30;

    // light2.postion.x = Math.con( time * 0.7 ) * 30;
    // light2.postion.y = Math.sin( time * 0.5 ) * 40;
    // light2.postion.z = Math.sin( time * 0.3 ) * 30;

    // light3.postion.x = Math.sin( time * 0.7 ) * 30;
    // light3.postion.y = Math.con( time * 0.5 ) * 40;
    // light3.postion.z = Math.con( time * 0.3 ) * 30;
  };

// draw scene
  var render = function( )
  {
      // move the CubeCamera to the position of the object
  //    that has a reflective surface, "take a picture" in each direction
  //    and apply it to the surface.
  // need to hide surface before and after so that it does not
  //    "get in the way" of the camera

  mirrorSphere.visible = false;
  mirrorSphereCamera.update( renderer, scene );
  mirrorSphere.visible = true;




  renderer.render( scene, camera );
  };




// google some game loops ;) run game loop (update, render, repeat)
  var GameLoop = function( )
  {
  requestAnimationFrame( GameLoop );
  update( );
  render( );

  };

GameLoop( );

</script>
<div id="container">
        Three.js Container
        <div id="buttons">
            <a href="https://www.metmuseum.org/art/collection#!?q=moon&perPage=20&department=19&showOnly=openaccess&sortBy=Relevance&sortOrder=asc&offset=0&pageSize=0">------:::::: Moon Metro Moon ::::::------ </a>
        </div>
    </div>
</body> 
</html>